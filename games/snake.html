<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Snake Classic</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Poppins', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
            background: radial-gradient(1200px 600px at 50% 10%, #1b2a4a, #0e1627 60%, #0b0f1b 100%);
            color: #e8f0ff;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }

        .game-wrap {
            position: relative;
            width: min(85vh, 85vw, 720px);
            height: min(85vh, 85vw, 720px);
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.45), inset 0 0 0 1px rgba(255, 255, 255, 0.06);
            background: linear-gradient(180deg, rgba(19, 32, 56, 0.9), rgba(10, 16, 28, 0.9));
            padding: 18px;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 12px;
            background: repeating-linear-gradient(90deg, #0f1a30 0 32px, #0e182c 32px 64px),
                repeating-linear-gradient(0deg, #0f1a30 0 32px, #0e182c 32px 64px);
            box-shadow: inset 0 0 0 2px rgba(255, 255, 255, 0.06);
        }

        .hud {
            position: absolute;
            top: -60px;
            left: 0;
            right: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            pointer-events: none;
        }

        .badge {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            padding: 8px 12px;
            font-weight: 600;
            color: #bcd3ff;
            text-shadow: 0 1px 0 rgba(0, 0, 0, 0.35);
        }

        .joystick-container {
            position: absolute;
            bottom: -140px;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 120px;
            pointer-events: none;
        }

        .joystick-base {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.08);
            border: 2px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35), inset 0 0 0 1px rgba(255, 255, 255, 0.06);
            position: relative;
            pointer-events: auto;
            touch-action: none;
        }

        .joystick-knob {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4a9eff, #2b6cff);
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 12px rgba(43, 108, 255, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.3);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: transform 0.1s ease;
            cursor: pointer;
        }

        .joystick-knob:active {
            transform: translate(-50%, -50%) scale(0.95);
        }

        .overlay {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 16px;
            background: linear-gradient(180deg, rgba(8, 12, 22, 0.78), rgba(8, 12, 22, 0.78));
            border-radius: 12px;
        }

        .title {
            font-weight: 800;
            font-size: clamp(24px, 4vw, 40px);
            letter-spacing: 0.5px;
            color: #8ecbff;
        }

        .subtle {
            color: #a7b8da;
            opacity: .9;
        }

        .cta {
            pointer-events: auto;
            padding: 12px 18px;
            background: linear-gradient(180deg, #2b6cff, #1f56d8);
            color: white;
            border: 0;
            border-radius: 10px;
            font-weight: 700;
            font-size: 16px;
            box-shadow: 0 12px 30px rgba(43, 108, 255, 0.35);
            cursor: pointer;
            transition: transform .1s ease, box-shadow .2s ease;
        }

        .cta:active {
            transform: translateY(1px);
            box-shadow: 0 8px 18px rgba(43, 108, 255, 0.25);
        }

        /* Mobile-specific styles */
        @media (max-width: 919px) {
            body {
                overflow-y: auto;
                padding: 20px 0;
            }

            .game-wrap {
                width: min(90vw, 90vh);
                height: min(90vw, 90vh);
            }

            .hud {
                top: -60px;
            }

            .joystick-container {
                display: block;
            }
        }

        /* Desktop styles */
        @media (min-width: 920px) {
            .hud {
                top: 10px;
                left: 10px;
                right: 10px;
            }

            .joystick-container {
                display: none;
            }
        }

        /* Very small screens */
        @media (max-height: 600px) {
            .game-wrap {
                width: min(80vh, 80vw);
                height: min(80vh, 80vw);
            }
        }
    </style>
    <link rel="icon" type="image/x-icon" href="../images/logo.png">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">
    <meta name="description" content="A modern, smooth Snake arcade game.">
</head>

<body>
    <div class="game-wrap">
        <div class="hud">
            <div class="badge">Score: <span id="score">0</span></div>
            <div class="badge">Best: <span id="best">0</span></div>
        </div>
        <canvas id="board" width="600" height="600" aria-label="Snake game area"></canvas>
        <div id="menu" class="overlay" role="dialog" aria-modal="true">
            <div class="title">Snake Classic</div>
            <div class="subtle">Use joystick or arrow keys</div>
            <button id="startBtn" class="cta">Play</button>
        </div>
        <div id="gameOver" class="overlay" style="display:none">
            <div class="title">Game Over</div>
            <div class="subtle">Final Score: <span id="final">0</span></div>
            <button id="restartBtn" class="cta">Restart</button>
            <a href="../index.html"><button id="back" class="cta">Back To Home Page</button></a>
        </div>
        <div class="joystick-container" aria-hidden="true">
            <div class="joystick-base" id="joystickBase">
                <div class="joystick-knob" id="joystickKnob"></div>
            </div>
        </div>
    </div>

    <script>
        (function () {
            const canvas = document.getElementById('board');
            const ctx = canvas.getContext('2d');
            const scoreEl = document.getElementById('score');
            const bestEl = document.getElementById('best');
            const menu = document.getElementById('menu');
            const gameOverEl = document.getElementById('gameOver');
            const finalEl = document.getElementById('final');

            // Grid settings
            const gridSize = 24; // number of cells per row/col
            const cell = canvas.width / gridSize; // cell pixels
            const speedBaseMs = 110; // base tick speed

            // Colors
            const colorSnake = '#6fffb0';
            const colorSnakeHead = '#b5ffd6';
            const colorFood = '#ffd166';
            const colorFoodGlow = 'rgba(255, 209, 102, 0.45)';

            // Game state
            let snake = [];
            let direction = { x: 1, y: 0 }; // initial moving right
            let nextDirection = { x: 1, y: 0 };
            let food = { x: 10, y: 10 };
            let score = 0;
            let best = Number(localStorage.getItem('snake_best') || 0);
            let loopId = null;
            let lastTickTs = 0;
            let tickInterval = speedBaseMs;
            let pendingGrowth = 0;
            let isRunning = false;

            bestEl.textContent = best;

            function resetGame() {
                snake = [
                    { x: 8, y: 12 },
                    { x: 7, y: 12 },
                    { x: 6, y: 12 }
                ];
                direction = { x: 1, y: 0 };
                nextDirection = { x: 1, y: 0 };
                placeFood();
                score = 0;
                scoreEl.textContent = score;
                tickInterval = speedBaseMs;
                pendingGrowth = 0;
                isRunning = true;
                lastTickTs = performance.now();
            }

            function start() {
                menu.style.display = 'none';
                gameOverEl.style.display = 'none';
                resetGame();
                loopId && cancelAnimationFrame(loopId);
                loopId = requestAnimationFrame(loop);
            }

            function gameOver() {
                isRunning = false;
                const gameover = new Audio('../sounds/game-over/game-over.wav');
                gameover.play();
                finalEl.textContent = score;
                if (score > best) {
                    best = score;
                    localStorage.setItem('snake_best', String(best));
                    bestEl.textContent = best;
                }
                gameOverEl.style.display = 'flex';
            }

            function placeFood() {
                do {
                    food.x = Math.floor(Math.random() * gridSize);
                    food.y = Math.floor(Math.random() * gridSize);
                } while (snake.some(s => s.x === food.x && s.y === food.y));
            }

            function update(dt) {
                // Apply buffered direction
                direction = nextDirection;

                // Move snake: compute new head
                const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

                // Wrap around for smooth arcade feel
                if (head.x < 0) head.x = gridSize - 1;
                if (head.x >= gridSize) head.x = 0;
                if (head.y < 0) head.y = gridSize - 1;
                if (head.y >= gridSize) head.y = 0;

                // Check self-collision
                if (snake.some((seg, i) => i > 0 && seg.x === head.x && seg.y === head.y)) {
                    return gameOver();
                }

                // Add head
                snake.unshift(head);

                // Eat food
                if (head.x === food.x && head.y === food.y) {
                    const successmusic = new Audio('../sounds/success/success.wav');
                    successmusic.play();
                    score += 5;
                    scoreEl.textContent = score;
                    pendingGrowth += 2;
                    placeFood();
                    // Slight speed up
                    tickInterval = Math.max(60, tickInterval - 2);
                }

                // Handle growth or tail removal
                if (pendingGrowth > 0) {
                    pendingGrowth--;
                } else {
                    snake.pop();
                }
            }

            function drawCell(x, y, fill, radius = 6) {
                const px = x * cell;
                const py = y * cell;
                const r = Math.min(radius, cell * 0.45);
                ctx.beginPath();
                ctx.moveTo(px + r, py);
                ctx.arcTo(px + cell, py, px + cell, py + cell, r);
                ctx.arcTo(px + cell, py + cell, px, py + cell, r);
                ctx.arcTo(px, py + cell, px, py, r);
                ctx.arcTo(px, py, px + cell, py, r);
                ctx.closePath();
                ctx.fillStyle = fill;
                ctx.fill();
            }

            function render() {
                // Clear
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Food glow
                const cx = food.x * cell + cell / 2;
                const cy = food.y * cell + cell / 2;
                const grd = ctx.createRadialGradient(cx, cy, 2, cx, cy, cell * 0.9);
                grd.addColorStop(0, colorFoodGlow);
                grd.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(cx, cy, cell * 0.9, 0, Math.PI * 2);
                ctx.fill();

                // Food
                drawCell(food.x, food.y, colorFood, 8);

                // Snake
                for (let i = snake.length - 1; i >= 0; i--) {
                    const seg = snake[i];
                    const t = i === 0 ? 1 : Math.max(0.25, 1 - i / (snake.length + 4));
                    const col = i === 0 ? colorSnakeHead : lerpColor(colorSnake, '#1fe0a1', t * 0.25);
                    drawCell(seg.x, seg.y, col, i === 0 ? 10 : 8);
                }
            }

            function lerpColor(a, b, t) {
                const ca = hexToRgb(a), cb = hexToRgb(b);
                const r = Math.round(ca.r + (cb.r - ca.r) * t);
                const g = Math.round(ca.g + (cb.g - ca.g) * t);
                const bl = Math.round(ca.b + (cb.b - ca.b) * t);
                return `rgb(${r}, ${g}, ${bl})`;
            }

            function hexToRgb(h) {
                const s = h.startsWith('#') ? h.slice(1) : h;
                const v = s.length === 3 ? s.split('').map(c => c + c).join('') : s;
                const num = parseInt(v, 16);
                return { r: (num >> 16) & 255, g: (num >> 8) & 255, b: num & 255 };
            }

            function loop(ts) {
                if (!isRunning) return;
                if (ts - lastTickTs >= tickInterval) {
                    lastTickTs = ts;
                    update(tickInterval);
                }
                render();
                loopId = requestAnimationFrame(loop);
            }

            // Input handling
            function setDirection(nx, ny) {
                // prevent reversing directly
                if (nx === -direction.x && ny === -direction.y) return;
                nextDirection = { x: nx, y: ny };
            }

            window.addEventListener('keydown', (e) => {
                switch (e.key) {
                    case 'ArrowUp': case 'w': case 'W':
                        e.preventDefault();
                        setDirection(0, -1);
                        break;
                    case 'ArrowDown': case 's': case 'S':
                        e.preventDefault();
                        setDirection(0, 1);
                        break;
                    case 'ArrowLeft': case 'a': case 'A':
                        e.preventDefault();
                        setDirection(-1, 0);
                        break;
                    case 'ArrowRight': case 'd': case 'D':
                        e.preventDefault();
                        setDirection(1, 0);
                        break;
                    case ' ':
                        e.preventDefault();
                        if (!isRunning) start();
                        break;
                }
            });

            // Joystick functionality
            const joystickBase = document.getElementById('joystickBase');
            const joystickKnob = document.getElementById('joystickKnob');

            let isJoystickActive = false;
            let joystickCenterX = 0;
            let joystickCenterY = 0;
            let joystickRadius = 35; // Maximum distance knob can move from center

            function initJoystick() {
                const rect = joystickBase.getBoundingClientRect();
                joystickCenterX = rect.left + rect.width / 2;
                joystickCenterY = rect.top + rect.height / 2;
            }

            function updateJoystickDirection(clientX, clientY) {
                const deltaX = clientX - joystickCenterX;
                const deltaY = clientY - joystickCenterY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                // Clamp to joystick radius
                const clampedDistance = Math.min(distance, joystickRadius);
                const angle = Math.atan2(deltaY, deltaX);

                const clampedX = Math.cos(angle) * clampedDistance;
                const clampedY = Math.sin(angle) * clampedDistance;

                // Update knob position
                joystickKnob.style.transform = `translate(${clampedX - 25}px, ${clampedY - 25}px)`;

                // Determine direction based on angle
                const threshold = 0.3; // Minimum movement to register direction
                if (clampedDistance > joystickRadius * threshold) {
                    if (Math.abs(clampedX) > Math.abs(clampedY)) {
                        // Horizontal movement
                        if (clampedX > 0) {
                            setDirection(1, 0); // Right
                        } else {
                            setDirection(-1, 0); // Left
                        }
                    } else {
                        // Vertical movement
                        if (clampedY > 0) {
                            setDirection(0, 1); // Down
                        } else {
                            setDirection(0, -1); // Up
                        }
                    }
                }
            }

            function resetJoystick() {
                joystickKnob.style.transform = 'translate(-50%, -50%)';
                isJoystickActive = false;
            }

            // Mouse events
            joystickBase.addEventListener('mousedown', (e) => {
                e.preventDefault();
                isJoystickActive = true;
                initJoystick();
                updateJoystickDirection(e.clientX, e.clientY);
            });

            document.addEventListener('mousemove', (e) => {
                if (isJoystickActive) {
                    updateJoystickDirection(e.clientX, e.clientY);
                }
            });

            document.addEventListener('mouseup', () => {
                if (isJoystickActive) {
                    resetJoystick();
                }
            });

            // Touch events
            joystickBase.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isJoystickActive = true;
                initJoystick();
                const touch = e.touches[0];
                updateJoystickDirection(touch.clientX, touch.clientY);
            });

            document.addEventListener('touchmove', (e) => {
                if (isJoystickActive) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    updateJoystickDirection(touch.clientX, touch.clientY);
                }
            }, { passive: false });

            document.addEventListener('touchend', () => {
                if (isJoystickActive) {
                    resetJoystick();
                }
            });

            document.getElementById('startBtn').addEventListener('click', start);
            document.getElementById('restartBtn').addEventListener('click', start);

            // Auto-resume with Enter on desktop
            window.addEventListener('keydown', (e) => {
                if ((e.key === 'Enter' || e.key === ' ') && menu.style.display !== 'none') {
                    e.preventDefault();
                    start();
                }
            });

            // Start paused at menu
            isRunning = false;
            render();
        })();
    </script>

</body>

</html>
